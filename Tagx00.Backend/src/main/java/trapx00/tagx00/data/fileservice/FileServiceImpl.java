package trapx00.tagx00.data.fileservice;

import net.sf.json.JSONObject;
import org.springframework.stereotype.Service;
import trapx00.tagx00.MainApplication;
import trapx00.tagx00.entity.Entity;
import trapx00.tagx00.exception.daoexception.IdDoesNotExistException;
import trapx00.tagx00.util.AnnotationUtil;

import java.io.*;
import java.lang.reflect.Field;
import java.util.ArrayList;

@Service
public class FileServiceImpl<T extends Entity> implements FileService<T> {
    private final static String savePath = MainApplication.class.getResource("../../../resources/data/").getPath();
    private final static String fileType = ".txt";

    /**
     * save the entity
     *
     * @param entity the entity object
     * @return the entity if success else return null
     */
    @Override
    public T saveTuple(T entity) {
        Class<? extends Entity> clazz = entity.getClass();
        String tableName = AnnotationUtil.getTableName(clazz);
        ArrayList<String> fileContent = new ArrayList<>();
        String id = AnnotationUtil.getKey(clazz);
        boolean isKeyAutoGenerated = AnnotationUtil.isKeyAutoGenerated(clazz);
        JSONObject json = JSONObject.fromObject(entity);

        int maxId = 0;
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(
                new FileInputStream(savePath + tableName + fileType)))) {
            boolean isUpdate = false;
            String jsonLine;
            while ((jsonLine = bufferedReader.readLine()) != null) {
                JSONObject jsonObject = JSONObject.fromObject(jsonLine);
                if (isKeyAutoGenerated && (Integer) jsonObject.get(id) > maxId) {
                    maxId = (Integer) jsonObject.get(id);
                }
                if (jsonObject.get(id).equals(json.get(id))) {
                    jsonLine = json.toString();
                    isUpdate = true;
                }
                fileContent.add(jsonLine);
            }
            if (!isUpdate) {
                if (isKeyAutoGenerated) {
                    json.element(id, maxId + 1);
                }
                fileContent.add(json.toString());
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }

        try (FileWriter writer = new FileWriter(savePath + tableName + fileType)) {
            writer.write("");
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (FileWriter writer = new FileWriter(savePath + tableName + fileType, true)) {
            for (String tuple : fileContent) {
                writer.write(tuple);
                writer.write(System.lineSeparator());
                writer.flush();
            }
            return entity;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * find a entity
     *
     * @param info the key info to find
     * @return the entity
     */
    @Override
    public T findOne(String info, Class<T> clazz) {
        String methodName = new Exception().getStackTrace()[2].getMethodName();
        String columnName = methodName.split("By")[1].toLowerCase();
        String tableName = AnnotationUtil.getTableName(clazz);

        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(
                new FileInputStream(savePath + tableName + fileType)))) {
            String json;
            while ((json = bufferedReader.readLine()) != null) {
                JSONObject jsonObject = JSONObject.fromObject(json);
                if (jsonObject.get(columnName).equals(info)) {
                    return fromJsonToObject(jsonObject, clazz);
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public void delete(String id, Class<T> clazz) {
        String tableName = AnnotationUtil.getTableName(clazz);
        ArrayList<String> fileContent = new ArrayList<>();
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(
                new FileInputStream(savePath + tableName + fileType)))) {
            boolean isExist = false;
            String jsonLine;
            while ((jsonLine = bufferedReader.readLine()) != null) {
                JSONObject jsonObject = JSONObject.fromObject(jsonLine);
                if (jsonObject.get(id).equals(id)) {
                    isExist = true;
                } else {
                    fileContent.add(jsonLine);
                }
            }
            if (!isExist) {
                throw new IdDoesNotExistException();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (FileWriter writer = new FileWriter(savePath + tableName + fileType)) {
            writer.write("");
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (FileWriter writer = new FileWriter(savePath + tableName + fileType, true)) {
            for (String tuple : fileContent) {
                writer.write(tuple);
                writer.write(System.lineSeparator());
                writer.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private T fromJsonToObject(JSONObject jsonObject, Class<T> clazz) {
        try {
            T t = clazz.newInstance();
            ArrayList<String> columns = AnnotationUtil.getAllFieldName(clazz);
            for (String column : columns) {
                Field field = clazz.getDeclaredField(column);
                field.setAccessible(true);
                field.set(t, jsonObject.get(column));
            }
            return t;
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        return null;
    }
}
